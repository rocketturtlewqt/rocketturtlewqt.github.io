<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>实习s on RocketTurtle</title>
    <link>https://rocketturtlewqt.github.io/%E5%AE%9E%E4%B9%A0/</link>
    <description>Recent content in 实习s on RocketTurtle</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 04 Aug 2021 23:45:52 +0800</lastBuildDate><atom:link href="https://rocketturtlewqt.github.io/%E5%AE%9E%E4%B9%A0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>上传全局配置文件视图渲染复杂度优化</title>
      <link>https://rocketturtlewqt.github.io/%E5%AE%9E%E4%B9%A0/%E4%B8%8A%E4%BC%A0%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%86%E5%9B%BE%E6%B8%B2%E6%9F%93%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BC%98%E5%8C%96/</link>
      <pubDate>Wed, 04 Aug 2021 23:45:52 +0800</pubDate>
      
      <guid>https://rocketturtlewqt.github.io/%E5%AE%9E%E4%B9%A0/%E4%B8%8A%E4%BC%A0%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%86%E5%9B%BE%E6%B8%B2%E6%9F%93%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BC%98%E5%8C%96/</guid>
      <description>上传全局配置文件  上传全局配置文件成功后，因前端不会再次发起请求，需要做个渲染处理。  方案一  将配置文件中的机器人配置读取出来，扔进数组里按照场景号排序，复杂度(nlogn)  方案二  观察到原数组是有序的，可以从后向前遍历，找到第一个场景号比当前要插入的场景号小的那条记录，调用js原生splice方法插入。复杂度(n)  successUploadFile(response, file) { console.log(&amp;#39;进入uploadFile&amp;#39;); const reader = new FileReader(); console.log(&amp;#39;response---&amp;#39;, response); console.log(file); if (response.status === 200) { reader.readAsText(file, &amp;#39;UTF-8&amp;#39;); reader.onload = (event) =&amp;gt; { const jsonConfig = JSON.parse(event.target.result); console.log(jsonConfig); if (jsonConfig &amp;amp;&amp;amp; jsonConfig.robotConfig &amp;amp;&amp;amp; jsonConfig.robotConfig.sceneConfig) { const newSceneConfig = jsonConfig.robotConfig.sceneConfig[0]; const len = this.tableDataOrigin.length; for (let i = len - 1; i &amp;gt;= 0; i--) { if (this.tableDataOrigin[i].id &amp;lt; newSceneConfig.</description>
    </item>
    
    <item>
      <title>模型录音原始录音下载</title>
      <link>https://rocketturtlewqt.github.io/%E5%AE%9E%E4%B9%A0/%E6%A8%A1%E5%9E%8B%E5%BD%95%E9%9F%B3%E5%8E%9F%E5%A7%8B%E5%BD%95%E9%9F%B3%E4%B8%8B%E8%BD%BD/</link>
      <pubDate>Wed, 04 Aug 2021 23:43:32 +0800</pubDate>
      
      <guid>https://rocketturtlewqt.github.io/%E5%AE%9E%E4%B9%A0/%E6%A8%A1%E5%9E%8B%E5%BD%95%E9%9F%B3%E5%8E%9F%E5%A7%8B%E5%BD%95%E9%9F%B3%E4%B8%8B%E8%BD%BD/</guid>
      <description>模型录音原始录音下载 背景  这个需求的出现背景是：排查后端是否对原始录音进行过截断处理。  步骤   根据blob对象去生成一个url
  创建一个a标签，将其href属性赋值为这个url，download属性赋值为时间戳.wav，表示下载后生成的文件名。
  创建audio标签，将其src也指向这个url。
  最后，就是将这几个新创建的标签放进原始的父级标签容器.
  downloadOrigin() { const url = URL.createObjectURL(this.blobRecord); const li = document.createElement(&amp;#39;li&amp;#39;); const au = document.createElement(&amp;#39;audio&amp;#39;); const hf = document.createElement(&amp;#39;a&amp;#39;); au.controls = true; au.src = url; hf.href = url; hf.download = new Date().toISOString() + &amp;#39;.wav&amp;#39;; hf.innerHTML = hf.download; li.appendChild(au); li.appendChild(hf); recordingslist.appendChild(li); } </description>
    </item>
    
    <item>
      <title>根据json配置导出json文件</title>
      <link>https://rocketturtlewqt.github.io/%E5%AE%9E%E4%B9%A0/%E6%A0%B9%E6%8D%AEjson%E9%85%8D%E7%BD%AE%E5%AF%BC%E5%87%BAjson%E6%96%87%E4%BB%B6/</link>
      <pubDate>Wed, 04 Aug 2021 23:39:39 +0800</pubDate>
      
      <guid>https://rocketturtlewqt.github.io/%E5%AE%9E%E4%B9%A0/%E6%A0%B9%E6%8D%AEjson%E9%85%8D%E7%BD%AE%E5%AF%BC%E5%87%BAjson%E6%96%87%E4%BB%B6/</guid>
      <description>根据json配置导出json文件 步骤   将json格式的对象转换为字符串形式，命名导出json配置的文件名。
  根据json格式的字符串创建一个blob对象。
  创建一个a标签，将download属性赋值为需要导出的文件名。
  根据blob对象，生成一个url，并将超链接的href属性设置为这个url。
  创建一个鼠标点击事件。
  向这个新创建的a元素派发这个鼠标点击事件。
  async saveJSON(data, filename) { if (!data) { console.log(&amp;#39;保存的数据为空&amp;#39;); return; } if (!filename) filename = &amp;#39;RobotJSON.json&amp;#39;; if (typeof data === &amp;#39;object&amp;#39;) { data = JSON.stringify(data); } // 创建一个blob数据  const blob = new Blob([data], { type: &amp;#39;text/json&amp;#39; }); const a = document.createElement(&amp;#39;a&amp;#39;); a.download = filename; // 将blob转为地址  // 创建url blob对象  a.</description>
    </item>
    
    <item>
      <title>浏览器关闭安全策略</title>
      <link>https://rocketturtlewqt.github.io/%E5%AE%9E%E4%B9%A0/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%B3%E9%97%AD%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/</link>
      <pubDate>Thu, 29 Jul 2021 00:12:47 +0800</pubDate>
      
      <guid>https://rocketturtlewqt.github.io/%E5%AE%9E%E4%B9%A0/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%B3%E9%97%AD%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/</guid>
      <description>  因本地调试需求，需要有一种跨域访问后端接口的方式。
  在语音合成功能模块，有个接口需要跨域调用，但是浏览器本身出于安全问题，有安全策略的限制，所以这个接口调用不成功。
  解决方案  在/Users/rt_wqt/Documents/路径下创建MyChromeDevUserData文件夹 =&amp;gt; /Users/rt_wqt/Documents/MyChromeDevUserData，rt_wqt改成自己的home名就可以了。 以命令行方式启动chrome浏览。  open -n /Applications/Google\ Chrome.app/ --args --disable-web-security --user-data-dir=&amp;lt;MyChromeDevUserData所在的绝对路径地址&amp;gt; </description>
    </item>
    
    <item>
      <title>解析上传的xlsx表格中的数据</title>
      <link>https://rocketturtlewqt.github.io/%E5%AE%9E%E4%B9%A0/%E8%A7%A3%E6%9E%90%E4%B8%8A%E4%BC%A0%E7%9A%84xlsx%E8%A1%A8%E6%A0%BC%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Sun, 25 Jul 2021 16:11:13 +0800</pubDate>
      
      <guid>https://rocketturtlewqt.github.io/%E5%AE%9E%E4%B9%A0/%E8%A7%A3%E6%9E%90%E4%B8%8A%E4%BC%A0%E7%9A%84xlsx%E8%A1%A8%E6%A0%BC%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/</guid>
      <description>解决方案  调用FileReader实例的api即可。    xlsx解析二进制文件。
  获取解析的xlsx内容。
  解析的xlsx内容转换为json格式。
  handleChangeFile(file) { if (!file) return; const reader = new FileReader(); reader.onload = (e) =&amp;gt; { const data = e.target.result; const workbook = XLSX.read(data, { type: &amp;#39;binary&amp;#39; }); //xlsx解析二进制文件  const worksheet = workbook.Sheets[workbook.SheetNames[0]]; //获取解析的xlsx内容  const json = XLSX.utils.sheet_to_json(worksheet); //解析的xlsx内容转换为json格式  const contentNew = []; json.forEach(item =&amp;gt; { if (Object.prototype.hasOwnProperty.call(item, &amp;#39;文本&amp;#39;)) { contentNew.push(item[&amp;#39;文本&amp;#39;]); } else { contentNew.</description>
    </item>
    
    <item>
      <title>Chrome高版本中非https无法打开摄像头和录音功能</title>
      <link>https://rocketturtlewqt.github.io/%E5%AE%9E%E4%B9%A0/chrome%E9%AB%98%E7%89%88%E6%9C%AC%E4%B8%AD%E9%9D%9Ehttps%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E6%91%84%E5%83%8F%E5%A4%B4%E5%92%8C%E5%BD%95%E9%9F%B3%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Sun, 25 Jul 2021 16:08:46 +0800</pubDate>
      
      <guid>https://rocketturtlewqt.github.io/%E5%AE%9E%E4%B9%A0/chrome%E9%AB%98%E7%89%88%E6%9C%AC%E4%B8%AD%E9%9D%9Ehttps%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E6%91%84%E5%83%8F%E5%A4%B4%E5%92%8C%E5%BD%95%E9%9F%B3%E5%8A%9F%E8%83%BD/</guid>
      <description>解决方案   在chrome中输入chrome://flags/#unsafely-treat-insecure-origin-as-secure。
  在方框内填写指定的url。
  保存。
  </description>
    </item>
    
    <item>
      <title>表格性能优化</title>
      <link>https://rocketturtlewqt.github.io/%E5%AE%9E%E4%B9%A0/%E8%A1%A8%E6%A0%BC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sun, 25 Jul 2021 16:00:38 +0800</pubDate>
      
      <guid>https://rocketturtlewqt.github.io/%E5%AE%9E%E4%B9%A0/%E8%A1%A8%E6%A0%BC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <description>&amp;lt;任务完成时间&amp;gt;是单独的一个db接口，抽取数据结果的时间略长。同时，&amp;lt;平均每道题目完成时间&amp;gt;依赖于&amp;lt;任务完成时间&amp;gt;和完成题目个数。 其它的列是单独的一个接口，当使用这两个接口同时生成表格时，换页会有明显较长时间的卡顿。  解决方案1   将两个接口分流，先用时间较短的接口进行表格框架的生成，再用db操作时间较长的接口填充剩余表格。
  将针对任务完成时间接口单独抽离出来，用异步请求的方式将结果集包装成一个数组，一次性渲染。
  缺陷：表格框架生成较快，但是任务时间列表可能还是需要等待一段时间才能被渲染。
  解决方案2   将两个接口分流，先用时间较短的接口进行表格框架的生成，再用db操作时间较长的接口填充剩余表格。
  与方案1不同的是，针对任务完成时间，即时请求即时渲染，不需要包装成结果集。
  缺陷：渲染顺序比较乱。
  async getFinishTime() { const taskList = this.tableData; taskList.forEach((task, index) =&amp;gt; { const rel = this.ajax.post(&amp;#39;/annotation/api/getTaskListTime&amp;#39;, { taskId: task.id }); const option = this.tableData[index]; rel.then(val =&amp;gt; { if (val &amp;amp;&amp;amp; val.data &amp;amp;&amp;amp; val.data.result) { const finishTime = val.data.result.tagger_time_all; if (finishTime) { option.finish_time = this.</description>
    </item>
    
  </channel>
</rss>
