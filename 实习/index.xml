<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>实习s on RocketTurtle</title>
    <link>https://rocketturtlewqt.github.io/%E5%AE%9E%E4%B9%A0/</link>
    <description>Recent content in 实习s on RocketTurtle</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 25 Jul 2021 16:00:38 +0800</lastBuildDate><atom:link href="https://rocketturtlewqt.github.io/%E5%AE%9E%E4%B9%A0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>表格性能优化</title>
      <link>https://rocketturtlewqt.github.io/%E5%AE%9E%E4%B9%A0/%E8%A1%A8%E6%A0%BC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sun, 25 Jul 2021 16:00:38 +0800</pubDate>
      
      <guid>https://rocketturtlewqt.github.io/%E5%AE%9E%E4%B9%A0/%E8%A1%A8%E6%A0%BC%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <description>&amp;lt;任务完成时间&amp;gt;是单独的一个db接口，抽取数据结果的时间略长。同时，&amp;lt;平均每道题目完成时间&amp;gt;依赖于&amp;lt;任务完成时间&amp;gt;和完成题目个数。 其它的列是单独的一个接口，当使用这两个接口同时生成表格时，换页会有明显较长时间的卡顿。  解决方案1   将两个接口分流，先用时间较短的接口进行表格框架的生成，再用db操作时间较长的接口填充剩余表格。
  将针对任务完成时间接口单独抽离出来，用异步请求的方式将结果集包装成一个数组，一次性渲染。
  缺陷：表格框架生成较快，但是任务时间列表可能还是需要等待一段时间才能被渲染。
  解决方案2   将两个接口分流，先用时间较短的接口进行表格框架的生成，再用db操作时间较长的接口填充剩余表格。
  与方案1不同的是，针对任务完成时间，即时请求即时渲染，不需要包装成结果集。
  缺陷：渲染顺序比较乱。
  async getFinishTime() { const taskList = this.tableData; taskList.forEach((task, index) =&amp;gt; { const rel = this.ajax.post(&amp;#39;/annotation/api/getTaskListTime&amp;#39;, { taskId: task.id }); const option = this.tableData[index]; rel.then(val =&amp;gt; { if (val &amp;amp;&amp;amp; val.data &amp;amp;&amp;amp; val.data.result) { const finishTime = val.data.result.tagger_time_all; if (finishTime) { option.finish_time = this.</description>
    </item>
    
  </channel>
</rss>
