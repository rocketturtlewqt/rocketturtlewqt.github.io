<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Serverlesses on RocketTurtle</title>
    <link>https://rocketturtlewqt.github.io/serverless/</link>
    <description>Recent content in Serverlesses on RocketTurtle</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 03 Jul 2021 16:15:30 +0800</lastBuildDate><atom:link href="https://rocketturtlewqt.github.io/serverless/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Serverless基本概念</title>
      <link>https://rocketturtlewqt.github.io/serverless/serverless%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Sat, 03 Jul 2021 16:15:30 +0800</pubDate>
      
      <guid>https://rocketturtlewqt.github.io/serverless/serverless%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid>
      <description>云函数计算基金会对serverless的定义   Serverless架构应该是采用Fass（函数即服务）和Sass（后端即服务）服务来解决问题的一种设计。
  狭义上的Serverless就是Fass+Sass的组合。
  Fass：Function as a Service。本质上就是一个函数运行平台，集成了触发器。它会负责服务器资源的调度和运维。
  Bass：Backend as a Service。可以理解为黑盒，Sererless将后端架构整个承担了下来，以接口的方式提供服务。
  Serverless优点   事件驱动：云函数也不是一直运行的，而是通过一定的条件触发。是通过一些类似消息事件、定时器等等触发的。产生事件的源头叫做触发器。
  按量付费：Serverless是按照fass调用次数，以及消耗的cpu、内存等资源按量计费的。Fass也会根据并发量生成多个函数实例。
  弹性伸缩：Bass也会根据并发亮自动调配服务器资源。实现了不同访问量的实时弹性伸缩。
  Fass和Bass的架构是分离计算和存储的架构。计算由Fass负责，存储由Bass负责。Fass和Bass也被分开部署和收费。应用的存储已经不是应用的一部分，而是演变为了独立的云服务器。
  Serverless缺点  严重依赖云平台厂商：例如A厂商认为数据可以采用sql形式存储，B厂商则认为还可以采用json格式形式存储。那么它们所对应的Fass接口是不同的。同一套代码是不可能在不同的Serverless产品上运行的。 开发调试困难，Serverless依赖云服务，本地难以搭建环境。 底层硬件不确定。bass是一个黑盒，有些代码必须使用特定的cpu和gpu运行的。  </description>
    </item>
    
  </channel>
</rss>
